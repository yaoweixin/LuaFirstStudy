--首先要明白一点，我们所有的全局变量都被存放在了我们的_G表：全局环境表
--在 Lua 中，全局变量被存储在一个名为 _G 的全局环境表中。这个表中存储了所有全局变量的键值对。
--当你在 Lua 中访问一个全局变量时，实际上是从这个表中查找相应的键值对，然后返回相应的值。
--Lua访问局部变量比访问全局变量快，主要是因为Lua在编译代码时，会为每个函数分配一个固定长度的数组，用于存储函数中的局部变量。
--这个数组在函数执行时被称为"栈"，访问局部变量时只需要从栈中取出相应位置的值即可，这个过程非常快速。
--而访问全局变量时，需要先在全局变量表中查找变量的值，这个过程需要额外的时间和开销。
--在 Lua 中，全局变量表是一个普通的 Lua 表，查找时需要进行哈希计算和查表等操作，相对于局部变量的访问，速度会更慢。
--Lua的全局环境表是一个普通的Lua表，用于存储全局变量。在Lua程序运行时，当需要读取一个变量时，如果当前环境表中不存在该变量，那么Lua会在该环境表的元表中寻找。
--如果元表也没有找到该变量，Lua会继续在元表的元表中查找，直到找到为止。如果最终还是没有找到该变量，则会抛出一个运行时错误。 
--尽量不要对我们的全局环境表进行修改

--访问全局变量可以： value = _G[varname]

--那如果是要反问全局环境表的变量中的变量，比如“io.read”,“a.b.c.d”
function getfield(f)
    local v = _G
    for w in string.gfind(f,"[%w_]+") do
        v = v[w]
    end
    return v
end

--来看一段等价的代码
local temp = a.b.c.d
temp.e = v 

a.b.c.d.e = v
-----------------------------
function setfield(f)
    local t = _G
    for w, d in string.gfind(f, "([%w_]+)(.?)") do
        if d == "." then
            t[w] = t[w] or {}
            t = t[w]
        else
            t[w] = v
        end
    end
end

setfield("t.x.y",10)
print(t.x.y)
print(getfield("t.x.y"))

